# -*- coding: utf-8 -*-
"""AIRSENSE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11c_7Bukb1xDUpshixhpkgAEpaV6X-XSi
"""

import pandas as pd
from sklearn.metrics import r2_score
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score
import matplotlib.pyplot as plt
import tensorflow as tf
from sklearn.preprocessing import MinMaxScaler
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
from keras.models import Sequential
from keras.layers import Dense, Flatten
from keras.utils import to_categorical
from tensorflow.keras.utils import plot_model
from PIL import Image
from sklearn.metrics import mean_absolute_error
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv1D, MaxPooling1D, Flatten, Dense
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import learning_curve
from tensorflow.keras.callbacks import History
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras.callbacks import ReduceLROnPlateau

df = pd.read_csv('delhi_aqi.csv')

df = df.dropna()
df = df[(df != 0).all(1)]

df.to_csv('cleaned_dataset.csv', index=False)

def calculate_aqi_for_pollutant(concentration, pollutant):
    if pollutant == 'NO2':
        breakpoints = [0, 54, 101, 361, 650, 1250, 1650, 2049, 4000]
        AQI_values = [0, 50, 100, 200, 300, 400, 500]
    elif pollutant == 'CO':
        breakpoints = [0, 4.4, 9.4, 12.4, 15.4, 30.4, 40.4, 50.4, 90]
        AQI_values = [0, 50, 100, 150, 200, 300, 400, 500]
    elif pollutant == 'SO2':
        breakpoints = [0, 36, 76, 186, 305, 605, 805, 1005, 5000]
        AQI_values = [0, 50, 100, 150, 200, 300, 400, 500]
    elif pollutant == 'O3':
        breakpoints = [0, 55, 71, 86, 106, 200, 405, 504]
        AQI_values = [0, 50, 100, 150, 200, 300, 400, 500]
    elif pollutant == 'PM2.5':
        breakpoints = [0, 12, 35.4, 55.4, 150.4, 250.4, 350.4, 500.4]
        AQI_values = [0, 50, 100, 150, 200, 300, 400, 500]
    else:
        raise ValueError("Invalid pollutant. Please choose 'NO2', 'CO', 'SO2', 'O3', or 'PM2.5'.")

    return calculate_aqi(concentration, breakpoints, AQI_values)

def calculate_aqi(concentration, breakpoints, AQI_values):
    for i in range(len(breakpoints) - 1):
        if breakpoints[i] <= concentration <= breakpoints[i + 1]:
            conc_low = breakpoints[i]
            conc_high = breakpoints[i + 1]
            aqi_low = AQI_values[i]
            aqi_high = AQI_values[i + 1]
            aqi = ((aqi_high - aqi_low) / (conc_high - conc_low)) * (concentration - conc_low) + aqi_low
            return aqi
    return None

df['AQI_no2'] = df['no2'].apply(lambda x: calculate_aqi_for_pollutant(x, 'NO2'))
df['AQI_so2'] = df['so2'].apply(lambda x: calculate_aqi_for_pollutant(x, 'SO2'))
df['AQI_o3'] = df['o3'].apply(lambda x: calculate_aqi_for_pollutant(x, 'O3'))
df['AQI_pm2_5'] = df['pm2_5'].apply(lambda x: calculate_aqi_for_pollutant(x, 'PM2.5'))


df.to_csv('updatedAQI.csv', index=False)

df.drop(columns=['co'], inplace=True)
df.to_csv('updatedAQI.csv', index=False)

df.drop(columns=['AQI_pm2_5'], inplace=True)

df['pm2_5'] = ((df['pm2_5'] - df['pm2_5'].min()) / (df['pm2_5'].max() - df['pm2_5'].min())) * 500

df.to_csv('updatedAQI.csv', index=False)

df['AQI_pm2_5'] = df['pm2_5'].apply(lambda x: calculate_aqi_for_pollutant(x, 'PM2.5'))

df.to_csv('updatedAQI.csv', index=False)


def health_issues_and_remedies_for_pollutant_aqi(pollutant, aqi):
    if pollutant == 'NO2':
        if aqi >= 0 and aqi <= 50:
            issue = "Minor respiratory irritation(NO2)"
            remedies = "Spend more time indoors in well-ventilated areas, avoid strenuous outdoor activities."
        elif aqi >= 51 and aqi <= 100:
            issue = "Increased respiratory symptoms in sensitive individuals(NO2)"
            remedies = "Limit outdoor activities, use air purifiers indoors."
        elif aqi >= 101 and aqi <= 150:
            issue = "Aggravation of respiratory conditions (asthma, bronchitis)(NO2)"
            remedies = "Stay indoors, use air purifiers with HEPA filters, consider wearing masks."
        else:
            issue = "Severe respiratory distress(NO2)"
            remedies = "Remain indoors with air purifiers, seek medical attention if symptoms worsen."
    elif pollutant == 'pm2_5':
        if aqi >= 0 and aqi <= 100:
            issue = "Minor headaches(pm2_5)"
            remedies = "Ventilate indoor spaces, reduce sources of CO (e.g., gas appliances)."
        elif aqi >= 100 and aqi <= 200:
            issue = "Headaches, dizziness(pm2_5)"
            remedies = "Increase ventilation, avoid using gas stoves without proper exhaust."
        elif aqi >= 200 and aqi <= 250:
            issue = "Nausea, fatigue(pm2_5)"
            remedies = "Immediately ventilate area, seek fresh air, and avoid further exposure."
        else:
            issue = "Severe symptoms (unconsciousness, death)(pm2_5)"
            remedies = "Evacuate to fresh air, seek medical attention immediately."
    elif pollutant == 'SO2':
        if aqi >= 0 and aqi <= 50:
            issue = "Minor respiratory irritation(SO2)"
            remedies = "Limit outdoor activities, use air purifiers indoors."
        elif aqi >= 51 and aqi <= 100:
            issue = "Increased respiratory symptoms in sensitive individuals(SO2)"
            remedies = "Avoid strenuous outdoor activities, use air purifiers indoors."
        elif aqi >= 101 and aqi <= 150:
            issue = "Aggravation of respiratory conditions (asthma, bronchitis)(SO2)"
            remedies = "Stay indoors, use air purifiers with HEPA filters, consider wearing masks."
        else:
            issue = "Severe respiratory distress(SO2)"
            remedies = "Remain indoors with air purifiers, seek medical attention if symptoms worsen."
    elif pollutant == 'O3':
        if aqi >= 0 and aqi <= 50:
            issue = "Minor respiratory irritation(O3)"
            remedies = "Limit outdoor activities, use air purifiers indoors."
        elif aqi >= 51 and aqi <= 100:
            issue = "Increased respiratory symptoms in sensitive individuals(O3)"
            remedies = "Avoid strenuous outdoor activities, use air purifiers indoors."
        elif aqi >= 101 and aqi <= 150:
            issue = "Aggravation of respiratory conditions (asthma, bronchitis)(O3)"
            remedies = "Stay indoors, use air purifiers with HEPA filters, consider wearing masks."
        else:
            issue = "Severe respiratory distress(O3)"
            remedies = "Remain indoors with air purifiers, seek medical attention if symptoms worsen."
    else:
        issue = "Invalid pollutant"
        remedies = "N/A"

    return issue, remedies

no2=df['AQI_no2']
so2=df['AQI_so2']
pm2_5=df['AQI_pm2_5']
o3=df['AQI_o3']
AQI=[]
issues=[]
remedies=[]
for i in range(len(df)):
    no2= df['AQI_no2'].iloc[i]
    so2=df['AQI_so2'].iloc[i]
    pm2_5=df['AQI_pm2_5'].iloc[i]
    o3=df['AQI_o3'].iloc[i]
    maxv = max(no2, so2, pm2_5,o3)
    AQI.append(maxv)
    if maxv == no2:
        pollutant = "NO2"
    elif maxv == so2:
        pollutant = "SO2"
    elif maxv == pm2_5:
        pollutant = "pm2_5"
    else:
        pollutant = "O3"
    [issue,remedy]=health_issues_and_remedies_for_pollutant_aqi(pollutant,maxv)
    issues.append(issue)
    remedies.append(remedy)
df['issues']=issues
df['remedies']=remedies
df['AQI']=AQI
df.to_csv('updatedAQI.csv', index=False)


df.dropna(inplace=True)
X = df[['AQI_no2', 'AQI_so2', 'AQI_o3','AQI_pm2_5']].astype(float)
y = df['AQI'].astype(float)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)


"""# **Random Forest**"""

X_train_rf = X_train.reshape(X_train.shape[0], -1)
X_test_rf = X_test.reshape(X_test.shape[0], -1)

rf_model = RandomForestRegressor()
rf_model.fit(X_train_rf, y_train)

rf_predictions = rf_model.predict(X_test_rf)

rf_mae = mean_absolute_error(y_test, rf_predictions)
rf_mse = mean_squared_error(y_test, rf_predictions)
rf_r_squared = r2_score(y_test, rf_predictions)

print("Random Forest:")
print("Mean Absolute Error:", rf_mae)
print("Mean Squared Error:", rf_mse)
print("R-squared:", rf_r_squared)

def plot_learning_curve(estimator, X, y, train_sizes=np.linspace(0.1, 1.0, 10), cv=5):

    train_sizes, train_scores, validation_scores = learning_curve(
    estimator, X, y, train_sizes=train_sizes, cv=cv, scoring='neg_mean_squared_error')

    train_scores_mean = np.mean(train_scores, axis=1)
    train_scores_std = np.std(train_scores, axis=1)
    validation_scores_mean = np.mean(validation_scores, axis=1)
    validation_scores_std = np.std(validation_scores, axis=1)


plot_learning_curve(rf_model, X_train_rf, y_train)

history = History()

rf_model.fit(X_train, y_train, validation_data=(X_train, y_train), epochs=10, callbacks=[history])

train_loss = history.history['loss']
val_loss = history.history['val_loss']

"""# **Regularizing**"""

model = Sequential([
    Dense(64, activation='relu', kernel_regularizer=tf.keras.regularizers.l2(0.01), input_shape=(X_train.shape[1],)),
    Dense(64, activation='relu', kernel_regularizer=tf.keras.regularizers.l2(0.01)),
    Dense(1)
])

model.compile(optimizer='adam', loss='mean_squared_error')

history = model.fit(X_train, y_train, epochs=100, batch_size=32, validation_split=0.2)

y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
print("Mean Squared Error:", mse)

lr_reduction = ReduceLROnPlateau(monitor='val_loss', factor=0.2, patience=5, min_lr=0.0001)
history = model.fit(X_train, y_train, epochs=100, validation_data=(X_train, y_train), callbacks=[lr_reduction])

early_stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)
model.compile(optimizer='adam', loss='mean_squared_error')
history = model.fit(X_train, y_train, epochs=100, validation_data=(X_train, y_train), callbacks=[early_stopping])

train_loss = history.history['loss']
val_loss = history.history['val_loss']

epochs = range(1, len(train_loss) + 1)

model.save('/content')